# leetcode
## array
### 88&119
对于一些增长型数列，每次增长会改变所有数，比如杨辉三角的每一行，可以考虑从最后往前更新
### 53
最大子序列，经典动态规划行为
### 62
注意分治思想
### 48
还有一种反转方法：357对角线对称一次，456中线对称一次
### 39
def A():中有变量a，函数B，a是B的全局变量<br>
copy.deepcopy(L)效果等同于L + []，但后者效果更好
### 64
可以从上到下，或者从左往右，按照行或者列做dp，不需要存储整个矩阵
### 75
第10行，判断如果是<,nums[high]这个数并没有被判断
### 40
上面是我的答案，下面是提交的比较快的方法：对比具体算法都是相同，但是时间快了一倍，后者结构较好<br>
很显然我的答案中主程序调用和递归中的判断重复，可以优化，但为什么快了这么多，不清楚
### 123
后序比前序方便的一点是边缘容易处理，有个比较快的答案用的的后序
### 105
用一些栈的性质修改list，比利用索引传递list子串快很多
### 74
二分查找大于、大于等于问题；取平均加一减一问题；mid减一加一问题
### 81
这个题做了很久，要先清楚具体具体步骤而不是熟悉了算法就开始做
### 56
比较容易想到的方法是，对start从小到大排序，然后从前往后扫<br>
我用的方法是对所有start和end分开排序，从新构造区间，事实证明可行，相对不好想，代码也比前者难<br>
实际上前面只需要一次排序，而排序比较费时间，所有前面更快
### 63
精妙的DP
### 18
不明白为什么比别人的慢，并没有什么特别的拷贝，别人用递归反而更快
## Linked List
### 141
比较快的答案是把fast一次两步拆解为一次一步，走两次，每次做判断，很巧妙，但是感觉计算量和我差不多
### 160
我的想法是把其中一个首尾相连结环，快指针，另一个慢指针，但是不对<br>
最快的答案是跑的时候，A跑完从B开始，B跑完从A开始，快慢指针，但是没看到return None的过程，很奇怪
### 109
链表求中点，可以用快慢指针，以此类推，可取任意分点
### 19
链表类问题，头指针需要专门做处理并且很麻烦时候，可以加一个无意义的头指针，会方便很多
### 148
链表的归并排序
### 143
别人的写的很漂亮
### 138
多指针链表的深度拷贝：首先肯定是按照某一个比较有序的指针构建，然后补充其余指针，可以参考这种插入的思想，<br>
解决新指针与原指针映射的问题
## Math
### 168
不含0的进制转换，含0转换到不含0比较特殊
### 69
传统二分法，还有一个牛顿迭代法
### 7
有没有办法不需要设label存正负，python无法直接检验是否超出范围，C++<br> int只需要判断前一个数与后一个是否十倍关系即可
### 12
最快答案比较有想法
### 50
一道非常不适合python的题，实际上最好的方法也就是二分法，python对判断是否出界问题不敏感<br>
但是leetcode不知道为什么递归这种进栈出栈操作反而会让速度加快，以至于二分法还不如这种复杂度O(n)的方法不停进出栈快
### 166
余数做标记找循环小数<br>
string不可直接插入，需要拼接
## String
### 29
变形的二分法<br>
位操作符
### 58
既然查找最后一个，就从后往前遍历
### 14
我的程序用res来存储最小子串，实际上放个index, 0-index即为最小子串
### 12
显然可以用KMP算法
### 22
比较剩余左右括号个数，可以省下第一参数value
### 49
sorted返回list，dict.values返回的不是list，要用list()修改<br>
list不可以当dict的键，tuple可以（少数tuple的用法）
### 6
这个题主要优化点在于边界判断，我的方法是一个个判断<br>
有个更好的办法，每一轮写入，都写入一竖一斜，作为一个循环，每个循环写入数量固定<br>
这样判断最后一次写入就行
### 71
'A'.join(list)，给list中所有元素前面加A拼成一个str
### 5
最大回文子串：manacher算法
### 91
第一反应是回溯，超时后意识到可以用动态规划
## Tree
### 104
很简单，注意用的方法是DFS，还可以用BFS，队列来记录层
### 108
if []:，不会被执行
### 101
表面看起来注释那行要比现在用的多计算一倍，但是实际上DFS，大部分情况(Fasle)只多计算一次，not and A， A不会被计算
### 110
我的算法，每个子树都要把子树节点深度算一遍，如果每次计算把深度和是否子树平衡返回就可以算一遍<br>
难点在于，递归调用返回一个bool和一个int非常繁琐<br>
别人做法一个非常巧妙的办法，如果用深度等于-1代表子树不平衡，不平衡返回-1，平衡返回深度
### 155
维护最小值的stack不需要保存所有元素，因为只有pop()这一个删除的操作，所有i这个位置只要保存0-i的最小值就可以
### 111
层次遍历更合适：大家一起往下走，谁先没儿子，谁最浅
### 173
这个题空间复杂度要求为树的高度，很容易想到是走的路径，一开始想法是标记向左向右，但是直接写入节点更加方便
### 199
我用的深度优先遍历，每一步要判断是否是最右的点，正确思路是层序遍历，最右输入result
### 116
层次遍历是一般的方法，还有一种很巧妙的方法：从上面，左边开始，直接利用父节点写好的next，同步现在的next（DP)
### 98
中序遍历是一种方法，分治法更好，注意如何不用递归写中序遍历